name: Testkube on vCluster with ArgoCD
on:
  workflow_dispatch:
  pull_request:
    branches:
      - main 

env:
  PR_NUMBER: ${{ github.event.number || github.run_id }}

jobs:
  run-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
     
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
            --zone ${{ secrets.GKE_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Install CLI tools
        run: |
          # Install vCluster CLI
          curl -sSL https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64 -o vcluster
          chmod +x vcluster
          sudo mv vcluster /usr/local/bin
          
          # Install ArgoCD CLI
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd-linux-amd64
          sudo mv argocd-linux-amd64 /usr/local/bin/argocd

      - name: Verify existing installations
        run: |
          echo "=== Host Cluster Info ==="
          kubectl cluster-info
          kubectl get nodes
          
          echo "=== Available Namespaces ==="
          kubectl get namespaces
          
          echo "=== Checking ArgoCD ==="
          kubectl get pods -n argocd || echo "ArgoCD namespace not found"
          
          echo "=== Checking Testkube ==="
          kubectl get pods -n testkube || echo "Testkube namespace not found"

      - name: Install or Verify ArgoCD
        id: install-argocd
        run: |
          echo "=== Checking ArgoCD Installation ==="
          
          # Check if ArgoCD namespace exists and has running pods
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "ArgoCD namespace exists, checking pods..."
            ARGOCD_PODS=$(kubectl get pods -n argocd --no-headers 2>/dev/null | wc -l)
            if [ "$ARGOCD_PODS" -gt 0 ]; then
              echo "ArgoCD pods found, checking if they're ready..."
              kubectl get pods -n argocd
              # Wait for existing ArgoCD to be ready
              kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd || echo "ArgoCD server not ready yet"
            else
              echo "ArgoCD namespace exists but no pods found, installing..."
              kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
              kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
            fi
          else
            echo "ArgoCD not found, installing..."
            kubectl create namespace argocd
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
          fi
          
          echo "=== ArgoCD Status ==="
          kubectl get pods -n argocd
          kubectl get svc -n argocd

      # ==================== vCluster Module ====================
      - name: Create vCluster
        id: create-vcluster
        run: |
          echo "=== Creating vCluster for PR $PR_NUMBER ==="
          
          # Create namespace
          kubectl create namespace demo-$PR_NUMBER --dry-run=client -o yaml | kubectl apply -f -
          
          # Create vCluster (simple approach)
          vcluster create testkube-vcluster-$PR_NUMBER \
            --namespace demo-$PR_NUMBER \
            --connect=false
          
          # Wait for vCluster to be ready
          echo "Waiting for vCluster to be ready..."
          kubectl wait --for=condition=ready pod -l app=vcluster --timeout=300s -n demo-$PR_NUMBER
          
          echo "=== vCluster created successfully ==="
          kubectl get all -n demo-$PR_NUMBER

      - name: Setup vCluster connectivity
        id: setup-vcluster
        run: |
          echo "=== Setting up vCluster connectivity ==="
          
          # Save the current (host) context before connecting to vCluster
          HOST_CONTEXT=$(kubectl config current-context)
          echo "HOST_CONTEXT=$HOST_CONTEXT" >> $GITHUB_ENV
          echo "Host cluster context: $HOST_CONTEXT"
          
          # Create kubeconfig for ArgoCD to use (without switching context)
          vcluster connect testkube-vcluster-$PR_NUMBER --namespace demo-$PR_NUMBER --print > vcluster-kubeconfig.yaml
          
          # Now connect to vCluster (this will switch the default context)
          vcluster connect testkube-vcluster-$PR_NUMBER --namespace demo-$PR_NUMBER &
          VCLUSTER_PID=$!
          echo "VCLUSTER_PID=$VCLUSTER_PID" >> $GITHUB_ENV
          
          # Wait for connection to establish
          sleep 30
          
          echo "=== Verifying vCluster connection ==="
          kubectl get nodes
          kubectl get namespaces
          
          # Create default namespace if it doesn't exist in vCluster
          kubectl create namespace default --dry-run=client -o yaml | kubectl apply -f -
          
          echo "=== vCluster connectivity established ==="

      # ==================== ArgoCD Module ====================
      - name: Get vCluster Service Details (Fixed)
        id: get-vcluster-details-fixed
        run: |
          echo "=== Getting vCluster Service Details ==="
          
          # Ensure we're on host context
          kubectl config use-context $HOST_CONTEXT
          
          # List all services in the vCluster namespace
          echo "Services in demo-$PR_NUMBER namespace:"
          kubectl get svc -n demo-$PR_NUMBER
          
          # Get the actual vCluster API server service (not DNS service)
          # The main vCluster service typically has port 443 and matches the vCluster name pattern
          VCLUSTER_SERVICE_NAME="testkube-vcluster-$PR_NUMBER"
          VCLUSTER_SERVICE_PORT="443"
          
          # Verify the service exists
          if kubectl get svc $VCLUSTER_SERVICE_NAME -n demo-$PR_NUMBER >/dev/null 2>&1; then
            echo "✅ Found vCluster API service: $VCLUSTER_SERVICE_NAME"
            # Get the actual port from the service
            VCLUSTER_SERVICE_PORT=$(kubectl get svc $VCLUSTER_SERVICE_NAME -n demo-$PR_NUMBER -o jsonpath='{.spec.ports[?(@.port==443)].port}')
            if [ -z "$VCLUSTER_SERVICE_PORT" ]; then
              VCLUSTER_SERVICE_PORT="443"  # fallback
            fi
          else
            echo "❌ vCluster API service not found, listing all services:"
            kubectl get svc -n demo-$PR_NUMBER
            exit 1
          fi
          
          echo "vCluster API service name: $VCLUSTER_SERVICE_NAME"
          echo "vCluster API service port: $VCLUSTER_SERVICE_PORT"
          
          # Set environment variables for use in subsequent steps
          echo "VCLUSTER_SERVICE_NAME=$VCLUSTER_SERVICE_NAME" >> $GITHUB_ENV
          echo "VCLUSTER_SERVICE_PORT=$VCLUSTER_SERVICE_PORT" >> $GITHUB_ENV
          
          # Get the correct secret name (the one with certificate data)
          VCLUSTER_SECRET_NAME="vc-testkube-vcluster-$PR_NUMBER"
          
          # Verify the secret exists
          if kubectl get secret $VCLUSTER_SECRET_NAME -n demo-$PR_NUMBER >/dev/null 2>&1; then
            echo "✅ Found vCluster secret: $VCLUSTER_SECRET_NAME"
          else
            echo "❌ vCluster secret not found, listing all secrets:"
            kubectl get secrets -n demo-$PR_NUMBER
            exit 1
          fi
          
          echo "VCLUSTER_SECRET_NAME=$VCLUSTER_SECRET_NAME" >> $GITHUB_ENV
          
          echo "=== vCluster service details collected successfully ==="

      - name: Register vCluster with ArgoCD (Fixed)
        id: register-vcluster-final
        run: |
          echo "=== Creating service account in vCluster for ArgoCD ==="
          
          # Debug: Print all environment variables
          echo "Environment variables:"
          echo "ARGOCD_SERVER: $ARGOCD_SERVER"
          echo "ARGOCD_PASSWORD: $ARGOCD_PASSWORD"
          echo "VCLUSTER_SERVICE_NAME: $VCLUSTER_SERVICE_NAME"
          echo "VCLUSTER_SERVICE_PORT: $VCLUSTER_SERVICE_PORT"
          
          # Get the actual vCluster context name
          VCLUSTER_CONTEXT_NAME=$(kubectl config get-contexts --kubeconfig=vcluster-kubeconfig.yaml --no-headers | awk '{print $2}' | head -1)
          echo "Using vCluster context: $VCLUSTER_CONTEXT_NAME"
          
          # Switch to vCluster to create service account
          kubectl config use-context "$VCLUSTER_CONTEXT_NAME"
          
          # Create service account for ArgoCD
          kubectl create serviceaccount argocd-manager -n kube-system
          kubectl create clusterrolebinding argocd-manager --clusterrole=cluster-admin --serviceaccount=kube-system:argocd-manager
          
          # Create token for the service account
          kubectl create token argocd-manager -n kube-system --duration=24h > vcluster-token.txt
          VCLUSTER_TOKEN=$(cat vcluster-token.txt)
          echo "Service account token created successfully"
          
          # Switch back to host context
          kubectl config use-context $HOST_CONTEXT
          echo "Switched back to host context"
          
          # Get vCluster CA certificate using the correct secret name
          VCLUSTER_CA=$(kubectl get secret $VCLUSTER_SECRET_NAME -n demo-$PR_NUMBER -o jsonpath='{.data.certificate-authority}')
          
          # Use the correct service name and port
          VCLUSTER_SERVER="https://$VCLUSTER_SERVICE_NAME.demo-$PR_NUMBER.svc.cluster.local:$VCLUSTER_SERVICE_PORT"
          echo "vCluster server endpoint: $VCLUSTER_SERVER"
          
          # Create token-based kubeconfig for ArgoCD
          cat > vcluster-token-kubeconfig.yaml << EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              certificate-authority-data: $VCLUSTER_CA
              server: $VCLUSTER_SERVER
            name: vcluster-pr-$PR_NUMBER
          contexts:
          - context:
              cluster: vcluster-pr-$PR_NUMBER
              user: vcluster-pr-$PR_NUMBER
            name: vcluster-pr-$PR_NUMBER
          current-context: vcluster-pr-$PR_NUMBER
          users:
          - name: vcluster-pr-$PR_NUMBER
            user:
              token: $VCLUSTER_TOKEN
          EOF
          
          echo "Created ArgoCD kubeconfig for vCluster"
          
          # Test connectivity from host cluster to vCluster (proper endpoint)
          echo "=== Testing vCluster API connectivity ==="
          kubectl run test-vcluster-api --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -k $VCLUSTER_SERVER/version --max-time 10 || echo "API connectivity test completed"
          
          # Login to ArgoCD with explicit parameters
          echo "=== Logging into ArgoCD ==="
          argocd login $ARGOCD_SERVER --username admin --password "$ARGOCD_PASSWORD" --insecure
          
          echo "=== Registering vCluster with ArgoCD ==="
          argocd cluster add vcluster-pr-$PR_NUMBER \
            --name vcluster-pr-$PR_NUMBER \
            --kubeconfig vcluster-token-kubeconfig.yaml \
            --yes
          
          # Verify cluster was added
          echo "Registered clusters:"
          argocd cluster list
          
          echo "=== vCluster registered with ArgoCD successfully ==="
      
      - name: Deploy Application via ArgoCD
        id: deploy-app
        run: |
          echo "=== Creating ArgoCD Application ==="
          
          # Ensure we're on host context for ArgoCD operations
          kubectl config use-context $HOST_CONTEXT
          
          # Create ArgoCD Application manifest
          cat > argocd-app-pr-$PR_NUMBER.yaml << EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: nginx-app-pr-$PR_NUMBER
            namespace: argocd
            finalizers:
              - resources-finalizer.argocd.argoproj.io
          spec:
            project: default
            source:
              repoURL: ${{ github.server_url }}/${{ github.repository }}
              targetRevision: ${{ github.head_ref || github.ref_name }}
              path: k8s
            destination:
              name: vcluster-pr-$PR_NUMBER
              namespace: default
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
              - CreateNamespace=true
              - ApplyOutOfSyncOnly=true
          EOF
          
          # Apply the application to host cluster (where ArgoCD runs)
          kubectl apply -f argocd-app-pr-$PR_NUMBER.yaml
          
          echo "=== ArgoCD Application created ==="
          kubectl get application nginx-app-pr-$PR_NUMBER -n argocd

      - name: Wait for Application Sync
        id: wait-sync
        run: |
          echo "=== Waiting for ArgoCD to sync application ==="
          
          # Ensure we're on host context for ArgoCD operations
          kubectl config use-context $HOST_CONTEXT
          
          # Login again to ensure session is active
          argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure
          
          # Wait for application to sync and be healthy
          argocd app wait nginx-app-pr-$PR_NUMBER --sync --health --timeout 300
          
          # Show application status
          argocd app get nginx-app-pr-$PR_NUMBER
          
          echo "=== Application synced successfully ==="

      - name: Verify Deployment in vCluster
        id: verify-deployment
        run: |
          echo "=== Verifying deployment in vCluster ==="
          
          # Get the actual vCluster context name
          VCLUSTER_CONTEXT_NAME=$(kubectl config get-contexts --kubeconfig=vcluster-kubeconfig.yaml --no-headers | awk '{print $2}' | head -1)
          echo "Using vCluster context: $VCLUSTER_CONTEXT_NAME"
          
          # Switch to vCluster context to check deployment
          kubectl config use-context "$VCLUSTER_CONTEXT_NAME"
          
          echo "Current context: $(kubectl config current-context)"
          echo "Checking deployment in vCluster..."
          
          # Check deployment status
          kubectl get all -n default
          kubectl wait --for=condition=available --timeout=300s deployment/nginx-deployment -n default
          
          # Test nginx service
          kubectl run test-pod --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -s http://nginx-service.default.svc.cluster.local
          
          echo "=== Deployment verified successfully ==="

      # ==================== Testkube Module ====================
      - name: Setup Testkube
        uses: kubeshop/setup-testkube@v1
        with:
          organization: ${{ secrets.TESTKUBE_ORG_ID }}
          environment: ${{ secrets.TESTKUBE_ENV_ID }}
          token: ${{ secrets.TESTKUBE_API_TOKEN }}

      - name: Provision ephemeral runner and run test
        id: run-tests
        run: |
          echo "=== Provisioning Testkube ephemeral runner ==="
          
          # Switch to host context for Testkube operations
          kubectl config use-context $HOST_CONTEXT
          
          # Provision ephemeral runner
          testkube install runner github-action-runner-${{ github.run_id }} \
            --create \
            --env ${{ secrets.TESTKUBE_ENV_ID }} \
            --namespace testkube \
            --floating
          
          echo "=== Running tests ==="
          
          # Run the test (targeting the vCluster)
          testkube run testworkflow curl-nginx-app \
           -f \
           --config url=http://nginx-service.default.svc.cluster.local \
           --target name=github-action-runner-${{ github.run_id }} \
           --tag pull-request=PR-${{ github.run_id }}
          
          echo "=== Tests completed ==="

      # ==================== Cleanup Module ====================
      - name: Cleanup ArgoCD Application
        if: always()
        run: |
          echo "=== Cleaning up ArgoCD Application ==="
          
          # Switch to host context for ArgoCD operations
          kubectl config use-context $HOST_CONTEXT || true
          
          # Login to ArgoCD
          argocd login $ARGOCD_SERVER --username admin --password $ARGOCD_PASSWORD --insecure || true
          
          # Delete ArgoCD application
          kubectl delete application nginx-app-pr-$PR_NUMBER -n argocd --ignore-not-found=true
          
          # Remove cluster from ArgoCD
          argocd cluster rm vcluster-pr-$PR_NUMBER --yes || true
          
          echo "=== ArgoCD cleanup completed ==="

      - name: Cleanup Testkube
        if: always()
        run: |
          echo "=== Cleaning up Testkube resources ==="
          
          # Switch to host context for Testkube operations
          kubectl config use-context $HOST_CONTEXT || true
          
          # Delete Testkube runner
          testkube delete runner github-action-runner-${{ github.run_id }} --delete --uninstall || true
          
          echo "=== Testkube cleanup completed ==="

      - name: Cleanup vCluster
        if: always()
        run: |
          echo "=== Cleaning up vCluster ==="
          
          # Kill port-forward processes
          kill $VCLUSTER_PID $ARGOCD_PORT_FORWARD_PID 2>/dev/null || true
          pkill -f "kubectl port-forward" || true
          pkill -f "vcluster connect" || true
          
          # Switch back to host context
          kubectl config use-context $HOST_CONTEXT || true
          
          # Disconnect vCluster
          vcluster disconnect || true
          
          # Delete vCluster and namespace
          vcluster delete testkube-vcluster-$PR_NUMBER --namespace demo-$PR_NUMBER || true
          kubectl delete namespace demo-$PR_NUMBER --ignore-not-found=true
          
          echo "=== vCluster cleanup completed ==="

      - name: Final Status Check
        if: always()
        run: |
          echo "=== Final Status Check ==="
          
          # Switch to host context
          kubectl config use-context $HOST_CONTEXT || true
          
          echo "Remaining demo namespaces:"
          kubectl get namespaces | grep demo- || echo "No demo namespaces remaining"
          
          echo "ArgoCD applications:"
          kubectl get applications -n argocd || echo "No applications found"
          
          echo "=== Workflow completed ==="
